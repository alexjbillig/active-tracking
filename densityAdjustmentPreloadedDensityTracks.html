<!DOCTYPE html>
<html>
<title>Density adjustment</title>
<link href="jsPsych-master/css/jspsych.css" rel="stylesheet" type="text/css"></link>
<body>

  <button id="startButton">Start</button>
  <button onclick="decreaseDensityLevel()">Decrease</button>
  <button onclick="increaseDensityLevel()">Increase</button>

  <p id="densityLevelDisplay"></p>
  <script>

  // 11th December 2020, A. Billig. One track per density level. Adjustments to
  // density level switches which track has full gain (all others set to zero).
  // Gain changes should happen at the next 10-ms silent period between bursts.
  // gain.gain.setValueAtTime(0, audioContext.currentTime)
  // gain.gain.setTargetAtTime(0.1, audioContext.currentTime, 1)
  // https://www.phpied.com/webaudio-deep-note-part-5-gain-node/

  const audioFilenameStart = "audio/fixedDensityLevelFullStimuli/densityLevel";
  const audioFilenameEnd = ".flac"
  const numLevels = 25;
  const numBursts = 40;
  const burstPlusSilenceDurSecs = 0.2;
  const sampleRate = 48000;
  const instance = 1; // This will change in due course, with one available per trial
  const startDelaySecs = 3;
  const bestAdjustTimeReBurstStartSecs = .195;
  const gainAdjustBufferSecs = .010; // If less than this remaining until next nominal gain adjustment time, skip to the next one

  // list of audio files
  var audioList = [];
  instanceString = instance.toString();
  for (i = 0; i < numLevels; i++) {
    levelString = (i + 1).toString();
    audioList[i] = audioFilenameStart +
    levelString.padStart(4, '0') + "_instance" + instanceString.padStart(4, '0') +
    audioFilenameEnd;
  }

  // get start button
  const startButton = document.querySelector('#startButton')

  // get audio context
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;

  // initialise density level
  var currentDensityLevel = 13;
  activeTrackIndex = currentDensityLevel - 1;
  document.getElementById('densityLevelDisplay').innerHTML = "Density level: " + currentDensityLevel;

  // initialise trackSource, gainnode, playing
  var trackSource = [];
  var gainNode = [];
  var playing = 0;

  // function for fetching the audio file and decode the data
  async function getFile(filepath) {
    const response = await fetch(filepath);
    const arrayBuffer = await response.arrayBuffer();
    const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
    return audioBuffer;
  }

  // function to call each file and return an array of decoded files
  async function loadFile(filePath) {
    const track = await getFile(filePath);
    return track;
  }

  // create a buffer, plop in data, connect and play
  function playTrack(audioBuffer, i) {
    trackSource[i] = audioCtx.createBufferSource();
    trackSource[i].buffer = audioBuffer;
    gainNode[i] = audioCtx.createGain();
    if (i == activeTrackIndex) {
      gainNode[i].gain.value = 1;
    }
    else {
      gainNode[i].gain.value = 0;
    }
    trackSource[i].connect(gainNode[i]).connect(audioCtx.destination)
    if (playing == 0) {
      startTime = audioCtx.currentTime + startDelaySecs;
      playing = 1;
      trackSource[i].onended = function () {
        playing = 0;
        audioCtx = null;
      }
    }
    trackSource[i].start(startTime);
    return trackSource;
  }

  // start button
  startButton.addEventListener('click', () => {
    if (audioCtx != null) {
      return;
    }
    audioCtx = new AudioContext();
    // hide start button
    // document.querySelector("#startButton").hidden = true;
    // iterate through audio files
    audioList.forEach((element, i) => {
      // load file
      loadFile(element).then((track) => {
        // check if context is in suspended state (autoplay policy)
        if (audioCtx.state === 'suspended') {
          audioCtx.resume();
        }
        // play track
        playTrack(track, i);
      })
    })
  });

  function increaseDensityLevel() {
    currentDensityLevel = Math.min(currentDensityLevel + 1, numLevels);
    activeTrackIndex = currentDensityLevel - 1;
    document.getElementById('densityLevelDisplay').innerHTML = "Density level: " + currentDensityLevel;
    if (playing == 1) {
      updateGainNodes();
    }
  }

  function decreaseDensityLevel() {
    currentDensityLevel = Math.max(currentDensityLevel -1, 1);
    activeTrackIndex = currentDensityLevel - 1;
    document.getElementById('densityLevelDisplay').innerHTML = "Density level: " + currentDensityLevel;
    if (playing == 1) {
      updateGainNodes();
    }
  }

  function updateGainNodes() {
    if (audioCtx.currentTime%burstPlusSilenceDurSecs < (bestAdjustTimeReBurstStartSecs - gainAdjustBufferSecs) {
      adjustmentTime = Math.floor(audioCtx.currentTime / burstPlusSilenceDurSecs) * burstPlusSilenceDurSecs + bestAdjustTimeReBurstStartSecs
    }
    else {
      adjustmentTime = Math.floor(audioCtx.currentTime / burstPlusSilenceDurSecs) * burstPlusSilenceDurSecs + burstPlusSilenceDurSecs + bestAdjustTimeReBurstStartSecs
    }
    for (i = 0; i < numLevels; i++) {
      gainNode[i].gain.setValueAtTime(0, adjustmentTime);
    }
    gainNode[activeTrackIndex].gain.setValueAtTime(1, adjustmentTime);
  };


  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }

  </script>

</body>
</html>
